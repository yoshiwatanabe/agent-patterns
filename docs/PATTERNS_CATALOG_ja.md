# MCP + Claude Skills統合パターンカタログ

## 概要

このカタログは、モデルコンテキストプロトコル（MCP）サーバーをClaudeエージェントスキルと統合するための主要なパターンをすべて文書化しています。これは、エージェントベースのシステムを構築するアーキテクトと開発者のための意思決定ガイドとして機能します。

**対象者**: カスタムAIアプリケーションの統合パターンを評価する高度な開発者、アーキテクト、および技術リード

**目的**: 以下を提供することで、情報に基づいた建築上の決定を可能にする：
- 図を含む完全なパターン説明
- 各パターンのメリット/デメリット分析
- 複雑性とトークン効率メトリクス
- 実際の使用例とシナリオ
- 意思決定フレームワークと比較マトリックス

---

## クイックパターンセレクター

ニーズに基づいてパターンを選択してください：

```
カスタムビジネスロジック/操作はありますか？
├─ はい → 自動呼び出しが必要ですか？
│   ├─ はい → パターン1：スキルガイドMCPツール ⭐
│   └─ いいえ → パターン6：直接MCP使用
└─ いいえ → 構造化ガイダンスが必要ですか？
    ├─ はい → パターン5：カスタムMCPなしのスキル
    └─ いいえ → 標準Claude Code機能を使用
```

---

---

## パターン1：スキルガイドMCPツール ⭐

**ステータス**: このプロジェクトで実装済み | **複雑性**: 中程度 | **トークン効率**: 高

### 概要

Claudeエージェントスキルがガイダンスと指示を提供し、Claudeが使用するMCPツールを自動的に決定するのに役立ちます。スキルはインテリジェントルーターとして機能し、各ツールいつどのように使用するかを説明します。Claudeの推論レイヤーがツール選択、パラメーター抽出、および多段階オーケストレーションを処理します。

### アーキテクチャ図

```
ユーザーリクエスト（自然言語）
       ↓
Claudeモデル
       ↓
[ファイルシステムから読み込まれたスキル]
  - 説明がリクエストと一致しますか？
  - 利用可能なツールが記載されています
       ↓
Claudeが使用するMCPツールを決定
       ↓
[MCPサーバー実行]
  - create_task
  - update_task
  - filter_tasks
  - など
       ↓
Claudeによって処理された結果
       ↓
ユーザーへのフォーマット済みレスポンス
```

### いつ使用するか

✅ **最適な用途**:
- ユーザーに向いたAIアプリケーション構築
- 自然言語インターフェース
- インテリジェンスが必要な多段階ワークフロー
- エンドユーザーがワークフローを定義するシステム
- ユーザビリティを優先するアプリケーション
- ユーザーリクエストに適応する機能

**例のシナリオ**:
- 自然言語を備えたタスク管理システム
- プロジェクト計画アシスタント
- チケットを管理するカスタマーサービスボット
- 個人生産性ツール
- ドキュメント処理システム

### いつ使用しないか

❌ **回避すべき場合**:
- 100%予測可能なツール実行が必要
- パフォーマンスが重要（モデル推論はレイテンシーを追加）
- ユーザーが技術的で明示的なコマンドを好む
- 内部CLIツールを構築している
- 各トークンが重要（よりシンプルな場合は直接MCPを使用）

### 特性

| 項目 | 評価 | 詳細 |
|--------|--------|---------|
| **複雑性** | 中程度 | スキル設計、MCPツール、SDK設定が必要 |
| **トークン効率** | 高 | 自然言語+推論はトークンを追加しますが、ラウンドトリップが少ない |
| **セットアップ労力** | 中程度 | スキルファイル、MCPサーバー、SDK設定が必要 |
| **メンテナンス** | 中程度 | ツール変更時にスキル説明を更新 |
| **スケーラビリティ** | 高 | 複雑な多段階ワークフローをよく処理 |
| **テスト可能性** | 中程度 | スキルの起動とツールチェーンをテストする必要がある |
| **開発速度** | 高 | スキルを一度書き込むと、多くのシナリオで動作 |
| **ユーザーエクスペリエンス** | 優秀 | 自然言語、暗記不要 |

### メリット ✅

- **自然言語インターフェース**: ユーザーは会話で対話でき、技術知識は不要
- **自動インテリジェンス**: Claudeがコンテキストに基づいて使用するツールを決定
- **柔軟なワークフロー**: コード変更なしでさまざまなユーザーリクエストに対応
- **自己文書化**: スキル説明がドキュメントとして機能
- **多段階自動化**: 必要に応じて操作を自動的にチェーン
- **スケーラブル設計**: 1つのスキルで100以上のユースケースを処理可能
- **簡単なメンテナンス**: スキルを1回更新すると、すべての操作に影響
- **最小限のクライアントコード**: シンプルなSDK呼び出し、複雑さはClaudeが処理

### デメリット ❌

- **レイテンシー**: モデル推論は直接ツール呼び出しと比べて処理時間を追加
- **トークンコスト**: より明示的なツール呼び出し（200-400対100-150/操作）より多くのトークン
- **制御が少ない**: 開発者は特定の実行パスを保証できない
- **スキル設計**: 良いスキル説明と例が必要
- **デバッグの複雑性**: Claudeがなぜツールを選択したかをトレースするのが難しい
- **大規模でのコスト**: 多くの操作=かなりのトークンコスト

### トークン使用分析

**典型的なリクエスト**: 「5つのタスクを持つプロジェクトを作成し、日付優先度でソートし、高優先度アイテムを表示」

トークン分解：
```
初期リクエスト+スキルコンテキスト：     約250トークン
  - ユーザーリクエスト
  - スキル説明
  - 利用可能なMCPツール
  - システム指示

Claude推論（ツール選択）：   約150トークン
  - リクエスト分析
  - どのツールを呼び出すかを選択
  - パラメーター決定

ツール呼び出し（5回呼び出し）：          約300トークン
  - 個別のツール呼び出し
  - パラメーター指定

MCP応答+処理：          約200トークン
  - MCPサーバーからの結果
  - Claude結果処理
  - レスポンスをフォーマット

最終出力：                        約100トークン

合計：約1000トークン
```

**トークン効率のヒント**:
- 簡潔なスキル説明を使用（コンテキストを削減）
- 大規模なデータセットにはMCPリソースを活用
- リスト操作にはページネーションを検討
- 可能な場合は結果をキャッシュ
- 複雑なワークフローにはプロンプトを使用

### 使用例

1. **タスク管理（プロジェクトコンテキスト）**
   - リクエスト: 「ウェブサイト再設計用の5つのタスクでプロジェクトを作成」
   - スキル起動: プロジェクト/タスクキーワードを認識
   - 使用ツール: create_project、create_task（5倍）
   - 結果: 完全に整理されたプロジェクト

2. **生産性分析**
   - リクエスト: 「完了率と最優先タスクを表示」
   - スキル起動: 分析リクエストを認識
   - 使用ツール: task_statistics、filter_tasks
   - 結果: パーソナライズされた生産性レポート

3. **インテリジェントサーチ**
   - リクエスト: 「認証関連の期限切れのバグをすべて検索」
   - スキル起動: 検索+フィルタリングを認識
   - 使用ツール: search_tasks、filter_tasks、get_overdue_tasks
   - 結果: 優先度付けされたバグリスト

4. **ワークフロー自動化**
   - リクエスト: 「完了したすべてのタスクを完了とマーク、ベロシティを計算」
   - スキル起動: ステータス更新を認識
   - 使用ツール: list_tasks、update_task（複数）、task_statistics
   - 結果: メトリクスが更新されたシステム

### 実装複雑性

**セットアップ**:
- 明確な説明でスキルファイルを定義
- 適切なパラメーターでMCPツールを実装
- マッチングプロンプトでスキル起動をテスト
- settingSources=["project"]でSDKを設定

**メンテナンス**:
- ツール変更時にスキル説明を更新
- ツール使用パターンを監視
- Claudeの使用方法に基づいて説明を改善
- エッジケースの例を追加

**テスト**:
- さまざまなプロンプトでスキル起動をテスト
- ツールチェーンが正しく機能することを確認
- 無効なパラメーターのエラー処理をチェック
- 実際のユーザーシナリオでテスト

### コード例

**スキルファイル** (`.claude/skills/task-organizer/SKILL.md`):
```yaml
---
name: task-organizer
description: タスクとプロジェクトを管理します。タスクの作成、優先度/ステータス別のフィルタリング、進捗の追跡に使用します。
---

# タスク整理者

利用可能な操作：
- タスクとプロジェクトを作成および更新
- 優先度、ステータス、プロジェクト別フィルター
- 完了統計を取得
- 期限切れアイテムを検索
```

**SDK使用法**:
```python
from claude_agent_sdk import query, ClaudeAgentOptions

options = ClaudeAgentOptions(
    cwd="/path/to/project",
    setting_sources=["project"],  # ファイルシステムからスキルを読み込む
    allowed_tools=["Skill", "mcp__task-manager__*"],
    mcp_servers={"task-manager": task_server}
)

# Claudeはリクエストに基づいてスキルを自動的に呼び出す
async for message in query(
    prompt="PRレビューのためのタスクを作成",
    options=options
):
    print(message)
```

### 関連パターン

- **代替案**: パターン6（直接MCP）-予測可能なツール呼び出し用
- **補完**: パターン3（MCPリソースをコンテキストとして）-大規模なデータセット用
- **前提条件**: パターン4（MCPプロンプトをワークフローとして）-複雑な操作用

### 意思決定チェックリスト

このパターンを使用する場合：
- [ ] 自然言語インターフェースが必要
- [ ] ユーザーがさまざまなリクエストを行う
- [ ] 多段階ワークフローが一般的
- [ ] トークンコストが重要ではない
- [ ] 良いスキル説明を設計できる

代替案を検討する場合：
- [ ] 100%予測可能な実行が必要
- [ ] すべてのミリ秒が重要（レイテンシー応答性）
- [ ] 技術ユーザー向けに構築している
- [ ] トークンバジェットが極めて限定的

---

## パターン2：マルチMCPオーケストレーション

**複雑性**: 高 | **トークン効率**: 中程度 | **推奨用途**: 統合集約型システム

### 概要

複数のMCPサーバーが連携して動作し、Claudeとスキルによってコーディネートされます。各MCPサーバーは特定のドメイン（データベース、API、ファイルなど）を処理し、Claudeのインテリジェンスはそれらの間の相互作用をオーケストレーションします。

### アーキテクチャ図

```
ユーザーリクエスト
    ↓
[オーケストレーションスキル]
    ↓
┌─────────────────────────────────────┐
│   Claude（インテリジェンス）        │
│  - どのサーバーを使用するかを決定    │
│  - データフローをコーディネート      │
│  - クロスドメインロジックを処理      │
└──────┬──────────────────────────────┘
       ↓
   並列/順次呼び出し
  /        |         \
 ↓         ↓          ↓
[DB MCP] [API MCP] [File MCP]
 ↓         ↓          ↓
 DB      外部        ファイル
結果     データ       結果
```

### いつ使用するか

✅ **最適な用途**:
- 複数のデータソースを持つシステム
- 複雑な統合（データベース+API+ファイル）
- 複数のドメインにまたがるワークフロー
- 専用サービスを持つエンタープライズシステム
- データ処理パイプライン

**例**: DB MCP+ストレージMCP+通知MCPを使用したバックアップシステム

### 特性

| 項目 | 評価 |
|--------|--------|
| **複雑性** | 非常に高い |
| **トークン効率** | 中程度 |
| **セットアップ労力** | 高 |
| **保守性** | 中程度 |
| **スケーラビリティ** | 優秀 |
| **信頼性** | 中程度（すべてのサーバーに依存） |

### メリット ✅

- 関心の分離（各MCPは1つのドメインを処理）
- 複数のアプリケーション間で再利用可能
- ドメイン別に特化したサーバー
- 並列実行が可能
- 新しいサーバーの追加が容易

### デメリット ❌

- 複雑なデバッグ（複数のサーバー）
- 依存関係管理（すべてのサーバーが稼働している必要がある）
- より高いトークンコスト（サーバー間の調整）
- ネットワーク/レイテンシー考慮事項
- 結果整合性の問題が発生する可能性がある

### トークン使用分析

```
オーケストレーションリクエスト：           約200トークン
マルチサーバーコーディネーション：       約500トークン
データベース操作：            約150トークン
外部API呼び出し：             約200トークン
結果の合成：               約100トークン

合計：約1150トークン
（単一MCP：約600トークンとの比較）

コスト：単一MCPの約2倍
```

### 使用例

1. **データパイプライン**: DB→抽出→APIで変換→ファイルに保存
2. **バックアップシステム**: データベースMCP（バックアップ）→クラウドMCP（アップロード）→通知MCP（アラート）
3. **レポート生成**: データMCP（クエリ）→分析MCP（計算）→エクスポートMCP（出力）

### 実装複雑性

- 中程度から高度
- サーバー間の依存関係を管理する必要がある
- コール全体でデータ一貫性を確保
- 部分的な失敗を適切に処理

---

## パターン3：MCPリソースをコンテキストとして

**複雑性**: 低 | **トークン効率**: 中程度 | **推奨用途**: 知識駆動型システム

### 概要

MCPサーバーは読み取り専用リソース（ドキュメンテーション、スキーマ、標準）を公開し、Claudeに文脈を提供します。これらのリソースは会話コンテキストの一部として読み込まれ、Claudeが動的にデータを取得する必要なく、より良い決定を下すのに役立ちます。

### アーキテクチャ図

```
ユーザーリクエスト
    ↓
MCPリソースを読み込む（読み取り専用）
    ↓
@docs:resource://coding-standards
@db:resource://schema
    ↓
Claude（エンリッチされたコンテキスト）
    ↓
教育的な意思決定
    ↓
ツール呼び出し（必要な場合）
```

### いつ使用するか

✅ **最適な用途**:
- ナレッジベース（ドキュメンテーション、標準、ガイドライン）
- スキーマ/仕様ファイル
- 設定リファレンス
- スタイルガイド付きのコード生成
- コンプライアンス/規制要件

### 特性

| 項目 | 評価 |
|--------|--------|
| **複雑性** | 低 |
| **トークン効率** | 中程度 |
| **セットアップ労力** | 低 |
| **パフォーマンス** | 優秀 |
| **キャッシュ可能性** | 高 |

### メリット ✅

- 実装が簡単
- 読み取り専用（副作用なし）
- 高度なキャッシュ可能性
- モデルの幻覚を減らす
- リソース経由で自己文書化

### デメリット ❌

- リソースサイズはトークンに影響
- 動的計算なし
- すべてのリソースを事前計算する必要がある
- 古いリソースが発生する可能性がある

### トークン使用

```
リソース読み込み：    約200トークン（キャッシュ済み）
コンテキストエンリッチメント：  約100トークン
モデル推論：     約150トークン
ツール使用：          約100トークン

合計：約550トークン
効率：高（リソースがキャッシュ済み）
```

### 使用例

1. **コード生成**: スタイルガイドリソースを読み込む→標準に一致するコードを生成
2. **ドキュメンテーションアシスタント**: APIスペックを読み込む→正確な詳細で質問に答える
3. **コンプライアンスチェッカー**: 規制を読み込む→ドキュメントのコンプライアンスを確認

---

## パターン4：MCPプロンプトをワークフローとして

**複雑性**: 中程度 | **トークン効率**: 高 | **推奨用途**: 複雑な操作

### 概要

MCPサーバーはプロンプト（事前作成された構造化されたワークフロー）を公開し、複雑な複数ステップの手順をエンコードします。スキルはこれらのプロンプトをトリガーして、個別のステップをオーケストレーションすることなく、完全なワークフローを実行します。

### アーキテクチャ図

```
ユーザーリクエスト（「週間レビュー」）
    ↓
スキル起動
    ↓
MCPプロンプト実行
    ↓
┌─────────────────────────┐
│ ワークフロー（組み込み）:     │
│ 1. 統計を取得       │
│ 2. ボトルネックを識別 │
│ 3. レポートをフォーマット        │
│ 4. サマリーを生成     │
└─────────────────────────┘
    ↓
完全なレポート
```

### いつ使用するか

✅ **最適な用途**:
- 定期的な複雑なワークフロー
- ベストプラクティス手順
- 固定パターンの複数ステップのプロセス
- ドメイン固有のワークフロー
- 監査/コンプライアンスルーチン

### 特性

| 項目 | 評価 |
|--------|--------|
| **複雑性** | 中程度 |
| **トークン効率** | 高 |
| **一貫性** | 優秀 |
| **柔軟性** | 低 |

### メリット ✅

- ドメイン専門知識をエンコード
- 非常に一貫した結果
- 効率的な実行
- 理解しやすい

### デメリット ❌

- ステップを動的に構築するほど柔軟ではない
- ワークフローの予測が必要

---

## パターン5：カスタムMCPなしのスキル

**複雑性**: 低 | **トークン効率**: 非常に高い | **推奨用途**: リーンなシステム

### 概要

スキルはカスタムMCPサーバーを必要とせずにガイダンスと指示を提供します。スキルは組み込みClaude Codeツール（Read、Write、Bash、Edit等）を使用して、Claudeをワークフロー全体でガイドします。

### アーキテクチャ図

```
ユーザーリクエスト
    ↓
[スキルが読み込まれました]
  （ベストプラクティスとアプローチを説明）
    ↓
Claudeが組み込みツールを使用
  /      |       \
Read   Write    Edit
（およびその他の標準ツール）
    ↓
結果を達成
```

### いつ使用するか

✅ **最適な用途**:
- ファイルベースの操作
- コード生成/変更
- 開発者支援ツール
- ドキュメンテーション生成
- プロジェクトスキャフォールディング

### 特性

| 項目 | 評価 |
|--------|--------|
| **複雑性** | 低 |
| **トークン効率** | 非常に高い |
| **セットアップ労力** | 最小限 |
| **パフォーマンス** | 優秀 |
| **スコープ** | ファイル操作に限定 |

### メリット ✅

- MCPサーバーが不要
- 非常に低いトークンオーバーヘッド
- 実装が簡単
- 既存のツールで動作
- 標準ツールを活用

### デメリット ❌

- ファイル操作に限定
- 外部システムにアクセスできない
- カスタムビジネスロジックなし

### トークン使用

```
スキルガイダンス:    約100トークン
ツール指示: 約50トークン
組み込みツール:    約150トークン

合計：約300トークン
（すべてのパターンの中で最も低いオーバーヘッド）
```

### 例：テスト駆動開発スキル

```yaml
---
name: tdd-guide
description: 標準ツールを使用してテスト駆動開発プラクティスに従います。
---

# TDDワークフロー

1. テスト失敗を記述
   - Writeツールを使用してテストファイルを作成

2. テストを実行
   - Bashを使用してテストを実行

3. 機能を実装
   - Editツールを使用してコードを変更

4. テストを再度実行
   - Bashですべてが成功することを確認
```

---

## パターン6：直接MCP使用（スキルなし）

**複雑性**: 低 | **トークン効率**: 非常に高い | **推奨用途**: 自動化/スクリプト

### 概要

スキルレイヤーなしでMCPツールを直接呼び出します。開発者がどのツールを呼び出すか、いつ呼び出すか、どのパラメーターで呼び出すかを制御します。モデル推論のオーバーヘッドなし。

### アーキテクチャ図

```
プログラム/スクリプト
    ↓
[直接ツール呼び出し]
    ↓
MCPサーバー
    ↓
結果
```

### いつ使用するか

✅ **最適な用途**:
- 自動化スクリプト/cronジョブ
- 既知の固定ワークフロー
- 開発者向けの内部ツール
- パフォーマンスが重要な操作
- テスト/統合シナリオ

### 特性

| 項目 | 評価 |
|--------|--------|
| **複雑性** | 非常に低い |
| **トークン効率** | 優秀 |
| **セットアップ労力** | 低 |
| **パフォーマンス** | 優秀 |
| **柔軟性** | 低 |

### メリット ✅

- 最大制御
- 最小トークン使用
- 非常に高速（モデル推論なし）
- 決定論的な動作
- デバッグが簡単

### デメリット ❌

- ツール名/パラメーターを知る必要がある
- インテリジェンスなし
- 複雑なワークフローの場合は詳細
- バリエーションの場合はコード変更が必要

### トークン使用

```
ツール仕様:  約50トークン
パラメーター:         約30トークン
実行:          約20トークン

合計：約100トークン
（最小オーバーヘッド）
```

### コード例

```python
# 従来のプログラミング-AIの推論なし
result = await mcp.call_tool(
    "mcp__task-manager__filter_tasks",
    {"priority": "high", "status": "pending"}
)
# 明示的、予測可能、効率的
```

---

## パターン7：ステートフルな会話MCP

**複雑性**: 高 | **トークン効率**: 中程度 | **推奨用途**: 長い会話

### 概要

MCPサーバーは会話ターン全体で状態を保持します。複数ターンの相互作用に役立つコンテキストが永続化する必要があります（会話、デバッグセッション、反復改善）。

### アーキテクチャ図

```
ターン1：ユーザーリクエスト
    ↓
MCPは文脈/状態を保存
    ↓
ターン2：フォローアップリクエスト
    ↓
MCPは状態を取得して更新
    ↓
ターン3+：保存されたコンテキストで続行
```

### いつ使用するか

✅ **最適な用途**:
- マルチターンデバッグセッション
- 反復設計/改善
- メモリのある会話
- 問題解決ワークフロー
- コードレビューセッション

### 特性

| 項目 | 評価 |
|--------|--------|
| **複雑性** | 高 |
| **トークン効率** | 中程度 |
| **一貫性** | 中程度（状態同期が必要） |
| **コンテキスト保存** | 優秀 |

### メリット ✅

- ターン全体で永続化されたコンテキスト
- より良いユーザーエクスペリエンス
- トークン削減（一部をサーバー状態に保存）
- 複雑なワークフローを可能にする

### デメリット ❌

- 状態管理の複雑性
- 同期化の問題が発生する可能性
- より多くのストレージが必要
- クリーンアップが必要

---

## パターン8：データパイプラインパターン

**複雑性**: 高 | **トークン効率**: 中程度 | **推奨用途**: ETL/データ処理

### 概要

複数のMCPサーバーの順次オーケストレーション。データは異なるサーバー全体での変換をフローします。

### アーキテクチャ図

```
入力データ
    ↓
[MCPを抽出]
    ↓
[MCPを変換]
    ↓
[MCPを読み込む]
    ↓
出力データ
```

### いつ使用するか

✅ **最適な用途**:
- データ移行
- ETLプロセス
- レポート生成
- データ分析パイプライン
- バッチ処理

### 特性

| 項目 | 評価 |
|--------|--------|
| **複雑性** | 高 |
| **トークン効率** | 中程度 |
| **スケーラビリティ** | 高 |
| **パフォーマンス** | 良好（順次） |

### トークン使用：パイプラインごとに約1500トークン

---

## パターン9：ハイブリッドローカル+リモートMCP

**複雑性**: 高 | **トークン効率**: 低 | **推奨用途**: 混合インフラストラクチャ

### 概要

ローカルSTDIO MCPサーバーをリモートHTTP MCPサーバーと同じアプリケーションで組み合わせます。

### いつ使用するか

✅ **最適な用途**:
- ローカルデータ+クラウドサービス
- オンプレミス+SaaS統合
- 開発+本番システム
- ハイブリッドインフラストラクチャ

### 特性

| 項目 | 評価 |
|--------|--------|
| **複雑性** | 高 |
| **レイテンシー** | 中程度（リモートはレイテンシーを追加） |
| **信頼性** | 中程度（双方への依存） |
| **セットアップ** | 高 |

---

## パターン10：セキュリティ/認可パターン

**複雑性**: 高 | **トークン効率**: 中程度 | **推奨用途**: 規制されたシステム

### 概要

MCPサーバーは操作を実行する前にセキュリティポリシーと認可チェックを適用します。

### いつ使用するか

✅ **最適な用途**:
- ヘルスケアシステム（HIPAA）
- 金融システム（SOX）
- 政府システム（コンプライアンス）
- 機密データの操作
- マルチテナントシステム

### 特性

| 項目 | 評価 |
|--------|--------|
| **複雑性** | 非常に高い |
| **セキュリティ** | 優秀 |
| **オーバーヘッド** | 中程度（認証チェック） |

### セキュリティ上の考慮事項

- MCPレベルでユーザー権限を検証
- 機密データを暗号化
- すべての操作を監査
- 機密操作をレート制限
- スキルを使用してポリシーを適用

---

## パターン11：階層的スキル

**複雑性**: 中程度 | **トークン効率**: 高 | **推奨用途**: 大規模システム

### 概要

親スキルが子スキルに委譲します。サブドメインを持つ複雑なシステムの整理に役立ちます。

### アーキテクチャ図

```
ユーザーリクエスト（複雑）
    ↓
[親スキル]
    ↓
    /    |    \
   ↓     ↓     ↓
[子] [子] [子]
スキル1  スキル2  スキル3
```

### いつ使用するか

✅ **最適な用途**:
- 大規模アプリケーション（100以上の操作）
- マルチドメインシステム
- チームベースの開発
- モジュラーアーキテクチャ

---

## パターン12：イベント駆動型MCP

**複雑性**: 非常に高い | **トークン効率**: 低 | **推奨用途**: リアクティブシステム

### 概要

MCPサーバーはイベント/ウェブフックを監視し、イベントに基づいてClaudeアクションをトリガーします。

### いつ使用するか

✅ **最適な用途**:
- CI/CD自動化
- リアルタイム監視
- ウェブフック駆動のワークフロー
- リアクティブシステム
- イベント処理

---

## パターン13：思考の連鎖とMCP

**複雑性**: 高 | **トークン効率**: 中程度 | **推奨用途**: 複雑な推論

### 概要

複雑な問題解決をステップに分解し、各ステップで異なるMCPツールを使用します。

### アーキテクチャ図

```
複雑な問題
    ↓
[分析フェーズ]（分析MCP）
    ↓
[設計フェーズ]（設計MCP）
    ↓
[実装フェーズ]（実装MCP）
    ↓
[検証フェーズ]（検証MCP）
    ↓
ソリューション
```

### いつ使用するか

✅ **最適な用途**:
- 複雑な問題解決
- アーキテクチャ設計
- 複数フェーズプロジェクト
- 科学計算
- 研究アプリケーション

### トークン使用：約2000以上（推論オーバーヘッド）

---

## パターン14：キャッシング+MCPリソース

**複雑性**: 中程度 | **トークン効率**: 非常に高い | **推奨用途**: 読み取り集約型システム

### 概要

MCPリソースと結果をキャッシュして、反復的なトークン使用を削減します。

### いつ使用するか

✅ **最適な用途**:
- リファレンスデータ（めったに変更されない）
- 大規模なリソースファイル
- トラフィックの多いシステム
- コストに敏感なアプリケーション

### キャッシング戦略

```
リクエスト1：@schemaを読み込む→200トークン
リクエスト2：キャッシュされた@schema→0トークン
リクエスト3：キャッシュされた@schema→0トークン

削減：最初のリクエスト後に400トークン削減
```

---

---

## パターン比較マトリックス

| パターン | 複雑性 | トークン効率 | 最適用途 | ラーニングカーブ |
|---------|------------|------------------|----------|-----------------|
| 1.スキルガイドMCP | 中程度 | 高 | ユーザー向けシステム | 中程度 |
| 2.マルチMCPオーケストレーション | 非常に高い | 中程度 | 複雑な統合 | 高 |
| 3.MCPリソースをコンテキストとして | 低 | 中程度 | ナレッジシステム | 低 |
| 4.MCPプロンプトをワークフローとして | 中程度 | 高 | 複雑な手順 | 中程度 |
| 5.スキル（カスタムMCPなし） | 低 | 非常に高い | ファイル操作 | 低 |
| 6.直接MCP使用 | 非常に低い | 非常に高い | 自動化スクリプト | 非常に低い |
| 7.ステートフルな会話 | 高 | 中程度 | マルチターンセッション | 高 |
| 8.データパイプライン | 高 | 中程度 | ETLプロセス | 高 |
| 9.ハイブリッドローカル+リモート | 非常に高い | 低 | 混合インフラ | 非常に高い |
| 10.セキュリティ/認可 | 非常に高い | 中程度 | 規制システム | 非常に高い |
| 11.階層的スキル | 中程度 | 高 | 大規模システム | 中程度 |
| 12.イベント駆動型MCP | 非常に高い | 低 | リアクティブシステム | 非常に高い |
| 13.思考の連鎖 | 高 | 中程度 | 複雑な推論 | 高 |
| 14.キャッシング+リソース | 中程度 | 非常に高い | 読み取り集約型システム | 中程度 |

---

## 意思決定フレームワーク

### 質問1：ユーザーは誰ですか？

- **エンドユーザー** → パターン1（スキルガイドMCP）を使用
- **開発者** → パターン6（直接MCP）を使用
- **混合** → パターン11（階層的スキル）を使用

### 質問2：MCPサーバーはいくつですか？

- **1つ** → パターン1、3、4、または5を使用
- **少数（2-3）** → パターン2（マルチMCP）を使用
- **多数（5+）** → パターン11（階層的）を使用

### 質問3：優先順位は何ですか？

- **自然言語インターフェース** → パターン1
- **最大速度** → パターン6
- **トークン効率** → パターン5または14
- **複雑なワークフロー** → パターン13
- **リアルタイムイベント** → パターン12

### 質問4：制約は何ですか？

- **規制/セキュリティ** → パターン10
- **ステートフルな会話** → パターン7
- **データ変換** → パターン8
- **ハイブリッドインフラ** → パターン9

---

## トークン効率ランキング

最も効率的から最も効率的でない順：

```
1.パターン6（直接MCP）           約100-200トークン
2.パターン5（スキルなし）  約300-500トークン
3.パターン4（プロンプトワークフロー）約400-600トークン
4.パターン1（スキルガイドMCP）     約600-1000トークン
5.パターン3（リソースをコンテキストとして）約500-800トークン
6.パターン14（キャッシング）             約300-500トークン（キャッシュ後）
7.パターン2（マルチMCP）            約1000-1500トークン
8.パターン7（ステートフル）             約700-1200トークン
9.パターン8（データパイプライン）        約1200-1800トークン
10.パターン13（思考の連鎖）   約1500-2500トークン
```

---

## 複雑性ランキング

最も単純から最も複雑：

```
1.パターン6（直接MCP）
2.パターン5（スキルなし）
3.パターン3（リソースをコンテキストとして）
4.パターン4（プロンプトワークフロー）
5.パターン1（スキルガイドMCP）
6.パターン14（キャッシング+リソース）
7.パターン11（階層的スキル）
8.パターン7（ステートフルな会話）
9.パターン8（データパイプライン）
10.パターン2（マルチMCPオーケストレーション）
11.パターン13（思考の連鎖）
12.パターン9（ハイブリッドローカル+リモート）
13.パターン12（イベント駆動型）
14.パターン10（セキュリティ/認可）
```

---

## アーキテクチャ意思決定ツリー

```
開始：「MCPとスキルを使用してシステムを構築する必要があります」
  │
  ├─ エンドユーザーが直接対話しますか？
  │  │
  │  ├─ はい → パターン1（スキルガイドMCP）を使用 ⭐
  │  │   └─ 自然言語インターフェースを提供
  │  │
  │  └─ いいえ → 開発者ツールですか？
  │      │
  │      ├─ はい、既知のワークフロー → パターン6（直接MCP）
  │      │   └─ 最大効率
  │      │
  │      └─ はい、多様なタスク → パターン11（階層的）
  │          └─ サブドメインを整理
  │
  ├─ カスタムビジネスロジックが必要ですか？
  │  │
  │  ├─ いいえ → 組み込みツールを使用できますか？
  │  │   │
  │  │   ├─ はい → パターン5（カスタムMCPなし）
  │  │   │   └─ 最小限の複雑性
  │  │   │
  │  │   └─ いいえ → パターン3（リソースをコンテキストとして）
  │  │       └─ ナレッジリソースを使用
  │  │
  │  └─ はい → 複数サーバーが必要ですか？
  │      │
  │      ├─ いいえ → パターン1（スキルガイド）
  │      │   └─ 単一サーバー、インテリジェント ルーティング
  │      │
  │      └─ はい → オーケストレーション複雑性？
  │          │
  │          ├─ 順次 → パターン8（データパイプライン）
  │          │   └─ ETLスタイル処理
  │          │
  │          └─ 並列 → パターン2（マルチMCP）
  │              └─ 複数サーバーをコーディネート
  │
  └─ 特殊な要件がありますか？
     │
     ├─ 規制コンプライアンス → パターン10
     ├─ リアルタイムイベント → パターン12
     ├─ 複雑な推論 → パターン13
     ├─ マルチターンセッション → パターン7
     ├─ 読み取り集約型操作 → パターン14（キャッシング）
     └─ 混合インフラ → パターン9
```

---

## 実装ロードマップ

### フェーズ1：基礎（1-2週）

最もシンプルなパターンから始めます：
1. **パターン6**（直接MCP）-ツール呼び出しに慣れる
2. **パターン5**（カスタムMCPなし）-スキルレイヤーを追加
3. **パターン3**（リソースをコンテキストとして）-ナレッジを提供

### フェーズ2：インテリジェンス（3-4週）

自動インテリジェンスを追加：
1. **パターン1**（スキルガイドMCP）-自然言語ルーティング
2. **パターン4**（プロンプトをワークフローとして）-複雑な手順をエンコード

### フェーズ3：スケール（5-8週）

複雑性を処理：
1. **パターン2**（マルチMCP）-複数サーバーをコーディネート
2. **パターン11**（階層的）-大規模システムを整理
3. **パターン8**（データパイプライン）-データフローを処理

### フェーズ4：高度（9週+）

特化したパターン：
1. **パターン7**（ステートフル）-永続的な会話
2. **パターン13**（思考の連鎖）-複雑な推論
3. **パターン10**（セキュリティ）-コンプライアンスと認可

---

## 一般的なピットフォールと解決策

### ピットフォール1：パターン選択を過度に複雑化

❌ **間違い**: 「いつか10個のMCPサーバーが必要になるかもしれないので、今すぐパターン2を構築しましょう」

✅ **正解**: パターン1から始め、実際に複数のサーバーがある場合にのみパターン2にリファクタリング

**教訓**: 過度なエンジニアリングはしないこと。シンプルに始めて、必要に応じてスケール

### ピットフォール2：トークンコストを無視

❌ **間違い**: 単純な操作にパターン13（2000以上のトークン）を使用

✅ **正解**: 既知のワークフローにはパターン6（100トークン）を使用

**教訓**: パターン複雑性を問題複雑性と一致させます。最もシンプルなソリューションが優勝。

### ピットフォール3：スキル説明が不十分

❌ **間違い**: 「ものを管理する」（曖昧、Claudeは起動しない）

✅ **正解**: 「タスクとプロジェクトを管理します。タスクを作成、更新、フィルター、および追跡します。タスク作成、プロジェクト計画、および生産性用に使用します。」（具体的、正しくトリガー）

**教訓**: スキル説明は重要です。良い執筆に時間を投資してください。

### ピットフォール4：エラーハンドリングを見逃す

❌ **間違い**: すべてのMCP呼び出しが成功すると仮定

✅ **正解**: フォールバック、再試行、明確なエラーメッセージを実装

**教訓**: 実際のシステムは失敗します。失敗を優雅に処理してください。

### ピットフォール5：パフォーマンスを無視

❌ **間違い**: すべてをシリアル化し、すべてのリソースを読み込む

✅ **正解**: 可能な場合は並列化、リソースをキャッシュ、結果をページネーション

**教訓**: パフォーマンスは重要です。監視して最適化してください。

---

## メトリクスと監視

### 追跡するキーメトリクス

```
パターン使用メトリクス：
- どのパターンが最も使用されていますか？
- スキル起動率
- ツール呼び出し頻度
- リクエストあたりの平均トークン

パフォーマンスメトリクス：
- レスポンスレイテンシー（P50、P95、P99）
- パターンごとのエラー率
- MCPサーバーの可用性
- キャッシュヒット率

コストメトリクス：
- ユーザーセッションあたりのトークン
- 操作あたりのコスト
- 時間経過に伴うコストトレンド
```

### 最適化チェックリスト

- [ ] スキル起動パターンを監視
- [ ] 利用されていないパターンを識別
- [ ] パターン別のトークン使用を測定
- [ ] エラー率と原因を追跡
- [ ] MCPサーバーのパフォーマンスを監視
- [ ] ユーザー満足度を測定
- [ ] リファクタリングの機会を識別

---

## 結論

選択するパターンは、特定の要件と一致する必要があります：

- **ユーザー向け**: パターン1（スキルガイドMCP）
- **自動化**: パターン6（直接MCP）
- **知識駆動**: パターン3（リソースをコンテキストとして）
- **複雑なワークフロー**: パターン13（思考の連鎖）
- **大規模システム**: パターン11（階層的スキル）

シンプルに始めます。必要に応じてスケール。継続的に測定して最適化します。

覚えておいてください：**問題を解決する最もシンプルなパターンが最適なパターンです。**

---

## さらに詳しく

- `MCP_SERVER.md`を参照してMCP実装の詳細を確認
- `SKILL_GUIDE.md`を参照してスキル開発のベストプラクティスを確認
- `SDK_USAGE.md`を参照して統合の例を確認
- `EXAMPLES.md`を参照して実際のコードサンプルを確認
